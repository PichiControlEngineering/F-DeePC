# Federated Data-enabled Predictive Control (DeePC)

## Overview
This project implements a Federated Data-enabled Predictive Control (DeePC) framework for any specified dynamic system. The script employs both a regular and federated DeePC controller to compare their performance and effectiveness in controlling the system.
We generate 3 trajectories, from which we construct 3 different DeePC controllers:
     1. The noiseless trajectory from the nominal system (oracle)
     2. A noisy variant of the oracle trajectory above (regular)
     3. A weighted average of many different trajectories, derived from similar systems (federated)
     
## Contents
- **Main Script (`DPC_BaseLine`)**: The primary script that initializes system parameters, generates data, constructs Hankel matrices, and executes control simulations.

## Requirements
- **MatLab Optimization Toolbox (quadprog.m)** Federated DeePC (or any predictive control method), solves a QP at each timestep. This implementation uses MatLabs quadprog, mainly for speed. Other QP programs, such as YALMIP or CVX can be used, but its implementation is not used here.
  
## How It Works
1. **Parameter Initialization**:
   - Statespace matrices of the nominal system (A, B, C, D) and DeePC settings (horizon, regularization, federated parameters) are defined.
   - Noise settings and input signal configurations are established.

2. **Data Generation & Hankel Matrices**:
   - System input-output data is collected using `systemDataGen.m`.
   - Hankel matrices are created using `createHankel.m` for different cases:
     - Regular noiseless control
     - Noisy control
     - Federated control (multiple systems with variations)

3. **Federated DeePC Implementation**:
   - Generate federated data-set by generating many trajectories from many controllers
   - Weighting factors are computed for federated data aggregation.
   - Federated Hankel matrices are generated by blending multiple system variations.

5. **Controller Execution**:
   - Three controllers are applied to the system:
     - **Regular DeePC (Noiseless, M=1)**
     - **Federated DeePC (M>1, leveraging distributed data)**
     - **Oracle Control (Optimal control using full noiseless data)**
   - The `DeePCcontroller.m` function is used to optimize control inputs, solving an online optimization using quadprog().

6. **Simulation & Visualization**:
   - The system is simulated with each controller using `stepStates.m`.
   - Performance metrics such as Mean Squared Error (MSE) and control effort are computed.
   - `PlotFunction.m` is used to visualize system state evolution and control signals.

## Dependencies (Non-Local Functions)
The main script relies on the following external functions:

| Function          | Description |
|------------------|-------------|
| `systemDataGen.m` | Generates input-output data for system identification. |
| `createHankel.m` | Constructs Hankel matrices for DeePC. |
| `addNoise.m` | Adds noise to signals to test robustness. |
| `stepStates.m` | Simulates system state evolution using a given controller. |
| `DeePCcontroller.m` | Implements the DeePC optimization procedure. |
| `createMatrices.m` | Constructs necessary matrices for DeePC optimization. |
| `PlotFunction.m` | Generates plots to visualize system performance. |

## Running the Script
To run the project:
1. Ensure all required functions are in the same directory as the main script, or can be reached by matlab.
2. Execute `DPC_Baseline.m` in MATLAB.
3. View generated plots and performance metrics for comparison.

# IEEE Paper
Feel free to check out the MatLab code in the `ConferencePaper` subsection, which was used to generate experiment data and figures for our submission to the IEEE "Conference on Decision and Control", titled "Toward Federated DeePC: borrowing data from similar systems" 
- The file `GenerateFigures.m` contains all the required code, together with the files in `init` to regenerate the data and corresponding figures in the paper
